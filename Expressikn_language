# HTN-GOAP Universal Planner

## Three Data Types

```
rule    trigger → state change       (world mechanics, no agency)
role    repeating priority rules     (reactive agency)
plan    sequential do/wait steps     (proactive agency)
```

## Two Step Keywords

```
do      actor acts        → Action.Approach { params }
wait    actor waits       → condition becomes true
```

## Actions

Every `do` resolves to the 7×3 action table + stealth/awareness modifiers + intensity/secrecy tradeoffs.

```
Action    | Direct         | Careful     | Indirect
----------|---------------|-------------|----------------
Move      | Athletics     | Riding      | Travel
Modify    | Operate       | Equipment   | Crafting
Attack    | Melee         | Ranged      | Traps
Defense   | Active Defense| Armor       | Tactics
Transfer  | Gathering     | Trade       | Administration
Influence | Persuasion    | Deception   | Intrigue
Sense     | Search        | Observation | Research
```

## Format: `.acf`

TOML-compatible flat sections + `{ }` nesting + bare expressions. No quotes except human text with spaces. Every step named. ALL_CAPS for jump targets only. Keyword IS the type, name IS the id.

```acf
plan military.siege [military, territorial] {

    params {
        target = EntityRef
        force = EntityRef
    }

    require { attack >= 30 }

    method assault {
        when {
            force.weight > target.garrison * 2
            force.skills.attack > 40
        }
        priority = force.drives.dominance * 0.5

        assemble: do military.assemble_force { destination = $target.region }
        survey:   do Sense.Careful { target = $target.walls }
        BREACH:   do military.breach_walls { walls = $target.walls }
            prob = sigmoid(force.skills.attack - target.walls.condition * 0.5)
            fail = STARVE
        storm:    do military.storm { garrison = $target.garrison }
    }

    method starve_out {
        when {
            force.weight > target.garrison * 1.2
            force.supplies > target.supplies * 1.5
        }
        priority = force.drives.survival * 0.7

        assemble: do military.assemble_force { destination = $target.region }
        STARVE:   do military.blockade { target = $target }
        exhaust:  wait target.supplies <= 0
            prob = prob(target.consumption_rate > target.supply_rate)
        demand:   do Influence.Direct { target = $target.leader }
    }

    done { target.owner == force.faction }
    fail { force.weight < 10 }

    counter threat.troops_massing {
        military.fortify      when self.walls.condition > 30
        military.sortie       when self.garrison > force.weight * 0.3
        political.call_allies when any(edge(self, *, alliance))
    }

    _provenance {
        sources = [
            { type = military_doctrine, id = fm3-90_ch12, confidence = 0.95 }
            { type = tvtropes, id = trope:TheSiege, confidence = 0.7 }
        ]
        verified = true
        reviewer = manu
    }
}
```

## Rules Are Switches

```
rule.prob = 0 → plans referencing it get confidence = 0 → pruned → cascades to
compounds, counters, roles. Game profiles are rule value tables.
```

```acf
rule fire_spread [physics, L0] {
    when region.fire > 0 AND adjacent.has(Flammable)
    rate = region.fire * 0.1 * region.wind
    effect: adjacent.fire += rate * dt
}
```

Rule categories:

```
L0 physics:     fire, water, temperature, gravity, light
L1 biology:     growth, hunger, disease, aging, death
L2 items:       decay, durability, spoilage, fuel
L3 social:      rumor spread, reputation decay, trust erosion
L4 economic:    supply/demand, price drift, scarcity
```

Game profiles swap rule values, not behavior:

```acf
profile political_sim {
    fire_spread = 0               # off
    disease_spread = 0            # off
    crop_growth = 1.0             # food is reliable
    rumor_spread = 0.5            # fast, intrigue heavy
}

profile survival {
    fire_spread = 0.2             # dangerous
    disease_spread = 0.1          # scary
    crop_growth = 0.05            # food is scarce
    rumor_spread = 0.05           # isolated, slow news
}
```

## No Culture System

Actors pick methods maximizing expected social outcome from local observers. "Culture" is shared knowledge v-items + local relationship patterns. Propagates through familiarity. Drifts naturally. No keyword, no overrides.

```
Move to new region → absorb local knowledge v-items through familiarity
  → predict consequences from local observers → adapt behavior
```

## No Contracts

Expectations are v-items in knowledge. Actors predict consequences, nothing is binding.

```
Custom:     expectation v-item + social_judgment rule
Law:        expectation v-item + social_judgment rule + authority role + punishment plan
Tradition:  expectation v-item, high familiarity propagation, slow decay
Taboo:      penalty-only expectation, no approval for compliance
Tyranny:    authority punishes without expectation v-items
```

Two generic rules handle all social enforcement:

```acf
rule social_judgment [social, L3] {
    when observer.knowledge.contains($expectation)
         AND observer.witnessed($actor, $action)
         AND $action != $expectation.expected_behavior
    effect: edge(observer, $actor, social).reputation -= $expectation.weight
}

rule social_approval [social, L3] {
    when observer.knowledge.contains($expectation)
         AND observer.witnessed($actor, $action)
         AND $action == $expectation.expected_behavior
    effect: edge(observer, $actor, social).reputation += $expectation.weight * 0.3
}
```

## Building Blocks

~80-100 composable compounds. Any plot is a sequence.

```
Information:  recon, investigate, eavesdrop, intercept, surveillance
Deception:    false_identity, plant_evidence, frame_target, cover_tracks, misdirect
Social:       seduce, blackmail, bribe, turn_agent, recruit, gossip_campaign
Economic:     smuggle, embargo, price_manipulation, counterfeit, extort, monopolize
Political:    coup, undermine_authority, forge_alliance, install_puppet, exile
Protection:   safehouse, dead_drop, escape_route, alibi
Violence:     ambush, assassination, sabotage, arson, poison, kidnap
```

Any plot composes from these:

```
Ocean's Eleven  = investigate → recruit → false_identity → smuggle → misdirect → escape
Game of Thrones = forge_alliance → turn_agent → undermine → frame → coup → blackmail
Breaking Bad    = smuggle → price_manipulation → bribe → false_identity → cover_tracks
```

## Roles

Universal skeletons, stacked per actor. Priority sorts across all active roles globally.

```acf
role farmer : laborer [economic, rural] {
    plow:    when season == spring AND field.state == fallow,  do Modify.Direct { target = $field, objects = [plow] },  priority = 10
    harvest: when season == autumn AND field.crop.ready,       do Transfer.Direct { source = $field },                  priority = 15
    pest:    when field.pests > 0,                             do Modify.Direct { target = $field.pests },              priority = 12
}
```

Roles gained/lost through world state, not assignment:

```
gain parent { when edge(self, *, parent_of) exists }
lose farmer { when NOT edge(self, *, employed_by WHERE type == farm) }
```

## Counter-Plans

Trigger from observable world state only. Never reference drives, plans, knowledge. Max depth 4.

```
Plan A: observable actions → ThreatSignature matches → Counter B selected
Counter B: observable actions → ThreatSignature matches → Counter C selected
Max 4 deep. Beyond that, knowledge confidence too low.
```

## Multi-Timescale

Same actions, different `dt`. Resolution auto-selects from weight × timestep.

```
weight == 1  AND dt <= minutes  → single roll
weight == 1  AND dt > minutes   → BernoulliOnce
weight > 1   AND dt <= days     → PoissonCount
weight > 1   AND dt > days      → NormalApprox
any          AND goal-threshold → TimeToThreshold (skip ticks)
```

## Probabilistic Planning

```
step.prob = Expression over actor/world state (never a constant)
plan.confidence = product(step.prob for critical path)
plan.utility = confidence × goal_value - total_cost
```

Bayesian posteriors from experience override dataset priors. Veterans pick better plans.

## Bundles

Compatible sets of rules + roles + plans + v-items + rule values. Not authored — discovered by sim stability testing. Local to spatial nodes.

```acf
bundle governance.feudal [governance] {
    expectations {
        obey_lord        { weight = 0.8, context = same_region }
        pay_taxes        { weight = 0.7, context = same_faction }
        military_service { weight = 0.6, context = when_called }
    }
    roles  { lord, vassal, serf, knight, bailiff }
    plans  { political.swear_fealty, political.grant_fief, military.levy_troops }
    rules  { loyalty_decay = 0.05, social_mobility = 0.01 }
    compatible   { economy.agrarian, economy.manor }
    incompatible { governance.democracy }
}
```

Discovery process:

```
1. Run sim with varied starting conditions
2. Observe which combinations stabilize together
3. Clusters that survive = bundles
4. Rule values that kept them stable = bundle defaults
```

## Settlement Templates

Spatial layout + resource requirements + stability criteria. Sim-tested.

```acf
template farming_village [settlement, rural] {
    layout {
        center:  { tags = [well, gathering_point] }
        fields:  { count = pop / 6, tags = [farmable], adjacent = water_source }
        housing: { count = pop / 4, tags = [shelter, enclosed] }
        storage: { count = 1, tags = [cold_storage, enclosed] }
    }
    nearby {
        water_source { distance <= 1 }
        forest       { distance <= 2 }
    }
    population {
        starting = 30
        roles = { farmer: pop * 0.4, gatherer: pop * 0.1, smith: 1 }
    }
    stable_when {
        food_supply > consumption * 1.2
        pop_after_20yr >= starting * 1.3
        survived_bad_harvest >= 1
    }
}
```

## LLM-Assisted Balancing

```
Designer intent (natural language)
  → LLM translates to rule constraints + acceptance metrics
  → sim runs headless
  → LLM interprets results vs intent
  → LLM adjusts values with explanation
  → repeat until stable + matches intent
```

Nudge strength controls emergent vs templated worldgen:

```
nudge = 0    freeform, anything goes
nudge = 0.5  attractors, civilizations tend toward coherent bundles
nudge = 1.0  snap to nearest template
```

## Provenance

`_provenance { }` in every file. Stripped by `if key.startsWith("_"): skip`. Stats in `.stats.acf` sidecars, gitignored.

## Validation

Expression lint, grounding, observability fence, decomposition depth ≤ 6, counter chains ≤ 4. Enforced at: LLM self-check → post-generate script → git pre-commit → CI.

## GitHub Agent Loop

```
Cron daily     → extract.yml     → LLM extracts batch → validates → PR
PR merged      → counters.yml    → generates counter-plans → PR
Cron weekly    → coverage.yml    → gap report as issue
Manual trigger → targeted extraction from specific source
```

## Extraction Sources

```
Narrative:   TVTropes, Propp, Polti, ATU folktales, Booker, Campbell
Military:    doctrine manuals, Clausewitz, Sun Tzu
Games:       Dwarf Fortress, RimWorld, CK3, D&D SRD, GURPS
Behavioral:  Maslow, BDI literature, game theory
Historical:  occupation manuals, guild records, legal codes, ethnographic databases
Everyday:    household management books, etiquette manuals, ritual taxonomies
```

## Extraction Priority

```
1. Rules (shape + defaults, implied by all other content)
2. 50-60 universal roles
3. 150 universal everyday plans
4. 80-100 composable compounds
5. Counter-plans and threat signatures
6. Bundles (discovered by sim, not authored)
7. Settlement templates (sim-tested layouts)
```

## Beyond Games

Same architecture works for any agent-based model. Different bundles, same engine. Historical simulation, supply chain, epidemic modeling, urban planning. Separate project.
