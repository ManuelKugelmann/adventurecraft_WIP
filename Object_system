# Object System Design - Groups, Secrecy & Knowledge Tracking

## Object Group Constraints

Object groups must satisfy **four coherence requirements**:

1. **Similar Stats/Template** - same category (weapons.basic, furniture.common)
2. **Shared Location** - same container/physical space
3. **Same Owner** - single ownership within group
4. **Similar Secrecy** - comparable secrecy levels (banded by 25-point ranges)

### Valid Object Groups
```javascript
"furniture_gareth_house_public"     // gareth's furniture, secrecy 0-25
"tools_gareth_workshop_private"     // gareth's tools, secrecy 25-50  
"weapons_gareth_vault_secret"       // gareth's weapons, secrecy 75-100
```

### Invalid Object Groups
- Mixed owners in same location
- Same items across different locations  
- Public and secret items together

## Object Secrecy System

### Generic Secrecy (0-100)
Objects have a single secrecy value from 0-100 that affects all actions involving that object. High secrecy objects like hidden daggers provide stealth advantages, while low secrecy objects like ornate ceremonial swords create stealth penalties.

### Secrecy as Stealth Tool
- **High secrecy objects** provide **stealth bonuses** to actions
- **Low secrecy objects** provide **stealth penalties** to actions
- Hidden daggers enable stealthy attacks while obvious great swords make stealth difficult

## MODIFY for Object Concealment

### Hiding Objects (Increase Secrecy)
MODIFY actions can be used to conceal objects, increasing their secrecy level and potentially changing their location to hidden spaces like secret compartments.

### Revealing Objects (Decrease Secrecy)
MODIFY actions can also reveal hidden objects, decreasing their secrecy and making them more publicly known.

## Knowledge Tracking System

### Knowledge Defaults by Secrecy & Proximity
- **Secrecy ≤ 30**: Public knowledge (based on temporal, spatial, interactional vicinity)
- **Secrecy > 30**: Private knowledge (explicit tracking required)

### Public Object Knowledge via Vicinity

For public objects (secrecy ≤ 30), knowledge is determined by three proximity factors:

**Temporal Vicinity** - How recently entity was near object. Knowledge decreases over time since last proximity.

**Spatial Vicinity** - How close entity currently is to object location. Same container provides highest knowledge, decreasing through same building, district, settlement.

**Interactional Vicinity** - Direct interaction gives perfect knowledge (distance = 0). Owning, using, or witnessing actions involving the object provides maximum confidence. Social connections to the owner provide moderate knowledge.

### Historical Proximity Tracking

**Leverage World History System:**
The object knowledge system leverages the existing world history infrastructure with its three-tier aging strategy:

- **Recent history (last 30 days)**: Full detail with complete action logs and run-length compression
- **Medium history (30-365 days)**: Snapshots and deltas only, action logs dropped for efficiency  
- **Ancient history (1+ years)**: Major milestone snapshots only

**Action Log Run-Length Compression:**
Repeated actions are automatically compressed into duration-based entries rather than storing each individual action.

**Public → Secret Transition Knowledge Capture:**
When objects transition from public to secret status, the system queries world history to identify all entities that had proximity during the object's public existence. Knowledge is captured based on interaction type and recency.

**History Aging Strategy:**
World history automatically ages by progressively dropping detail levels. Action logs are dropped after 30 days, delta snapshots after 1 year, leaving only major milestone snapshots for ancient history.

**Combined Public Knowledge:**
```javascript
function getPublicKnowledge(object, entity) {
  let temporal = getTemporalVicinity(object, entity);
  let spatial = getSpatialVicinity(object, entity);
  let interactional = getInteractionalVicinity(object, entity);
  
  return {
    confidence: Math.max(temporal, spatial, interactional),
    last_known_location: object.location,
    basis: "vicinity" // temporal/spatial/interactional
  };
}
```

### Hybrid Tracking Model

**Public Knowledge Baseline:**
Objects (or global public database) store last public location and timestamp as a shared baseline. All actors use this as the default starting point for public object knowledge.

**Actor Knowledge Entries:**
Actors store personal knowledge about objects in their knowledge databases using standard hierarchical topics. This includes secret knowledge, personal interactions, and specialized information.

**Knowledge Query Process:**
1. **Public objects**: Start with shared public baseline, apply vicinity modifiers based on actor's proximity history
2. **Secret objects**: Check actor's personal knowledge database first, fall back to public baseline with decay
3. **Specialized knowledge**: Always stored in actor's personal knowledge database

### Knowledge Query Logic
```javascript
function getLocationKnowledge(object, entity) {
  // Check explicit knowledge first (secret objects or special cases)
  if (object.location_knowledge[entity]) {
    return object.location_knowledge[entity];
  }
  
  // Public objects use vicinity-based knowledge
  if (object.secrecy <= 30) {
    return getPublicKnowledge(object, entity);
  }
  
  // Secret objects without explicit knowledge - fall back to last public state
  let days_elapsed = current_day - object.last_public_state.timestamp;
  let confidence = Math.max(20, 80 - (days_elapsed * 5));
  
  return {
    location: object.last_public_state.location,
    confidence: confidence, 
    timestamp: object.last_public_state.timestamp
  };
}
```

## Update Patterns

### Secret Actions (Secrecy > 30)
- Update location_knowledge only for action observers
- Others retain last_public_state knowledge (with decay)
- Minimal storage - only track exceptions

### Public Actions (Secrecy ≤ 30)
- Reset last_public_state to new location
- Clear individual location_knowledge tracking
- Return to public baseline

## Efficiency Benefits

### Storage Optimization
- **Public baseline**: Last public location stored at object level or global public database for efficiency
- **Actor knowledge**: Personal/secret object knowledge in standard hierarchical knowledge entries
- **World history aging**: Progressive detail reduction (action log → deltas → snapshots only)
- **Shared public state**: Eliminates redundant storage of "everyone knows this" information
- **Proximity calculations**: On-demand vicinity modifiers applied to shared baseline

### Realistic Behavior
- **Actor-centric memory**: Each actor maintains their own object knowledge based on personal experience
- **Public object vicinity**: Knowledge calculated from actor's historical proximity to objects
- **Multi-resolution history**: Actor memory detail fades over time as world history ages
- **Natural knowledge gaps**: Actors only know what they've personally encountered or been told

### Scalable Implementation
- **Actor knowledge system**: Leverage existing hierarchical knowledge structure for object locations
- **Unified world history**: Single infrastructure for all temporal proximity queries
- **Automatic aging**: Actor memory detail reduces as world history ages (30 days → 1 year → 10+ years)
- **Run-length compression**: Repeated actions automatically compressed in world history
- **Clean separation**: Objects store basic properties, actors store knowledge about objects
- **Natural information distribution**: Knowledge emerges from actor experience rather than global tracking