# AdventureCraft Data Specification v1.0

## Overview

Three data types. One expression language. One file format.

```
rule    trigger → state change       (world mechanics, no agency)
role    repeating priority rules     (reactive agency)
plan    sequential do/wait steps     (proactive agency)
```

---

## 1. File Format: `.acf`

### 1.1 Tokens

```
Keyword     = rule | role | plan | method | do | wait | when | done | fail
            | require | counter | params | effect | bundle | template
            | profile
Identifier  = [a-zA-Z_][a-zA-Z0-9_]*
QualifiedId = Identifier ('.' Identifier)*
ParamRef    = '$' QualifiedId
Number      = [0-9]+ ('.' [0-9]+)?
Bool        = true | false
String      = '"' [^"]* '"'              # ONLY for human text with spaces
Symbol      = { } [ ] ( ) = , : + - * / < > >= <= == != += -=
Comment     = '#' rest_of_line
Label       = [A-Z][A-Z0-9_]* ':'       # jump target
StepName    = [a-z][a-z0-9_]* ':'       # human-readable step name
```

### 1.2 Quoting Rule

Quoted: only human-readable text containing spaces.
Unquoted: identifiers, tags, refs, expressions, keywords, numbers, bools.

### 1.3 Declaration

```ebnf
File        = Declaration+
Declaration = DeclType QualifiedId Inheritance? Tags? '{' Body '}'
DeclType    = 'rule' | 'role' | 'plan' | 'bundle' | 'template' | 'profile'
Inheritance = ':' QualifiedId
Tags        = '[' Identifier (',' Identifier)* ']'
Body        = (Section | Entry | NamedBlock)*
Section     = Keyword '{' Body '}'
NamedBlock  = Identifier '{' Body '}'
Entry       = StepEntry | RuleEntry | Assignment | BareExpr
```

### 1.4 Step Entries

```ebnf
StepEntry   = StepName DoStep StepProps?
            | Label DoStep StepProps?
DoStep      = 'do' ActionRef ActionArgs?
            | 'wait' Expr
ActionRef   = Action '.' Approach           # e.g. Attack.Direct
            | QualifiedId                    # e.g. military.breach_walls
ActionArgs  = '{' (Identifier '=' Expr (',' Identifier '=' Expr)*)? '}'
StepProps   = (Indent (ProbLine | FailLine | WhenLine))*
ProbLine    = 'prob' '=' Expr
FailLine    = 'fail' '=' Label
WhenLine    = 'when' Expr
```

### 1.5 Role Rule Entries

```ebnf
RuleEntry   = StepName 'when' Expr ',' DoStep (',' 'priority' '=' Expr)?
```

### 1.6 Example

```acf
plan criminal.heist [criminal, economic] {

    params {
        vault = SpatialRef
        crew = EntityRef
        mark = EntityRef
    }

    require { sense >= 40 }

    method classic {
        when {
            crew.weight >= 3
            any(edge(crew, *, member_of) WHERE skills.modify > 50)
        }
        priority = self.drives.luxury * 0.6

        case_joint:  do Sense.Indirect { target = $vault, secrecy = 0.8 }
        profile:     do Sense.Careful { target = $mark }
        recruit:     do Influence.Indirect { target = $specialists }
        disguises:   do Modify.Indirect { target = disguises }
        distract:    do Influence.Indirect { target = $guard, false = true }
        infiltrate:  do Move.Careful { target = $vault, secrecy = 0.9 }
        CRACK:       do Modify.Direct { target = $vault_door }
            prob = sigmoid(crew.skills.crafting - $vault.security)
            fail = ABORT
        grab:        do Transfer.Direct { source = $vault, secrecy = 0.9 }
        ABORT:       do Move.Indirect { destination = $safehouse, secrecy = 0.9 }
        cleanup:     do cover_tracks {}
    }

    done { self.inventory.value > $vault.former_value * 0.5 }
    fail { any(edge(self, *, known_by) WHERE faction == law_enforcement) }
}
```

---

## 2. Expression Language

### 2.1 Two Primitives

All world state access resolves to:

```
entity.path                                          → value
edge(from, to, type, [path], [depth], [agg])         → value
```

### 2.2 Full Grammar

```
Expr =
    # Terminals
    | entity.path                                     → value
    | edge(from, to, type, [path], [depth], [agg])    → value
    | $param                                          → value
    | Number | Bool
    | prob(Expr)                                      → 0..1
    | random(min, max)                                → value

    # Math
    | Expr { + - * / } Expr
    | min(Expr, Expr) | max(Expr, Expr) | abs(Expr)
    | sigmoid(Expr)                                   → 0..1

    # Comparison → bool
    | Expr { < > == != >= <= } Expr

    # Logical → bool
    | Expr AND Expr | Expr OR Expr | NOT Expr

    # Aggregate
    | count(entities WHERE Expr)
    | any(entities WHERE Expr)
    | sum(entities, path)
```

### 2.3 Edge Query Modes

```
edge(a, b, type)                     # direct: exists? + payload
edge(a, b, type, depth)              # transitive: any path within N hops
edge(a, b, type, depth, agg)         # transitive + aggregate along path
```

Aggregation functions:

| Agg | Returns |
|-----|---------|
| exists | bool: any path within depth |
| min_depth | int: shortest hop count |
| sum(field) | float: total along path |
| min(field) | float: bottleneck value |
| max(field) | float: peak value |
| product(field) | float: decay chains |

### 2.4 Edge Types

| Type | From → To | Payload |
|------|-----------|---------|
| social | entity → entity | debt, reputation, affection, familiarity |
| member_of | entity → group | rank, since |
| owns | entity → object/spatial | — |
| holds | entity → object/spatial | — |
| contains | container → object | — |
| located_in | entity → spatial_node | — |
| connected_to | spatial → spatial | throughput, terrain_cost |
| adjacent | spatial → spatial | — |
| parent_of | entity → entity | — |
| parent_template | entity → template | — |
| hostile_to | faction → faction | — |
| allied_with | faction → faction | — |
| knows_about | entity → entity/fact | confidence, freshness |
| guards | entity → entity/spatial | — |
| delegates_to | entity → entity | scope, grants |
| supplies | spatial → spatial | resource_type, flow_rate |

### 2.5 Effects

```
Effect =
    | entity.path += Expr
    | entity.path -= Expr
    | entity.path = Expr
    | entity => destroy
    | entity => create(template_id, { params })
    | edge(a, b, type) => add({ payload })
    | edge(a, b, type) => remove
```

### 2.6 Sugar

| Sugar | Resolves To |
|-------|-------------|
| HAS(e, item, n) | e.inventory[item] >= n |
| AT(e, loc) | e.location == loc |
| ALIVE(e) | e.health > 0 |
| CONTROLS(f, r) | edge(f, r, controls) |
| CONNECTED(a, b) | edge(a, b, connected_to, 99, exists) |

Named sugar defined as bare expressions in data files. Resolved at load time.

---

## 3. Entity State Schema

### 3.1 Attributes (9 — 3×3)

```
              Power       Coordination   Endurance
Physical      str         agi            bod (HP)
Mental        wil         int            spi (mana)
Social        authority*  cha            reputation*
```

*authority and reputation derived from relationship patterns, never stored.

### 3.2 Skills (23 + 2 meta)

```
Action     Direct           Careful          Indirect
────────   ──────           ───────          ────────
Move       athletics        riding           travel
           str+agi          agi+int          int+wil
Modify     operate          equipment        crafting
           str+int          agi+int          int+wil
Attack     melee            ranged           traps
           str+agi          agi+int          int+wil
Defense    active_defense   armor            tactics
           agi+str          str+bod          int+wil
Transfer   gathering        trade            administration
           str+agi          cha+int          int+wil
Influence  persuasion       deception        intrigue
           cha+wil          cha+int          int+wil
Sense      search           observation      research
           agi+int          int+wil          int+spi
```

Meta-skills: stealth (reduces detection), awareness (improves detection).

### 3.3 Drives (7)

```
survival:    0-100     safety, basic needs
luxury:      0-100     comfort, fine goods
dominance:   0-100     control, authority
belonging:   0-100     relationships, community
knowledge:   0-100     learning, discovery
lawful:      0-100     0=chaotic, 50=neutral, 100=lawful
moral:       0-100     0=evil, 50=neutral, 100=good
```

### 3.4 Relationships (4-axis, asymmetric)

```
debt:        -100..+100   obligation balance
reputation:  -100..+100   fear↔respect
affection:   -100..+100   hate↔love
familiarity: 0-100        interaction history
```

Any entity → any entity. High familiarity → personal relationship dominates inherited group relationship.

### 3.5 Knowledge (3 tiers)

```
Tier 1: Local observation + role scope   → query world state (free, current)
Tier 2: Skill gates                      → on-demand checks (free, stat block)
Tier 3: Virtual items                    → remote/hidden/unique (runtime cost, possibly stale/wrong)
```

V-item fields: freshness, source, obscurity, confidence. Obscurity controls propagation (0=public, 1=secret).

---

## 4. Rules

### 4.1 Structure

A rule defines a state change triggered by a condition. No agency. Evaluated every tick, scaled by dt.

```acf
rule <id> [tags] {
    when <Expr>
    rate = <Expr>            # for continuous effects
    prob = <Expr>            # for stochastic events (per unit time)
    effect: <Effect>
}
```

`rate` and `prob` are mutually exclusive. `rate` = deterministic accumulation × dt. `prob` = stochastic event with batch scaling.

### 4.2 Multi-rule shorthand

Multiple rules in one block when they share context:

```acf
rule fire [physics, L0] {
    spread:  when region.fire > 0 AND adjacent.has(Flammable),
             prob = region.fire * 0.1 * region.wind,
             effect: adjacent.fire += 20

    consume: when region.fire > 0,
             rate = region.fire * 0.1,
             effect: region.fuel -= rate * dt

    quench:  when region.fire > 0 AND region.water > 0,
             rate = region.water * 0.5,
             effect: region.fire -= rate * dt

    starve:  when region.fire > 0 AND region.fuel <= 0,
             rate = 20,
             effect: region.fire -= rate * dt
}
```

### 4.3 Rule Layers

```
Layer  Domain     Agency   Depends On   Typical dt
─────  ──────     ──────   ──────────   ──────────
L0     Physics    None     Nothing      minutes
L1     Biology    None     L0           hours-days
L2     Items      None     L0           days
L3     Social     None*    L0-L2        days
L4     Economic   None*    L0-L3        days-weeks
```

*L3/L4 rules are agentless (things that happen TO actors, not chosen). Rumor spreads whether anyone intends it. Prices drift without anyone deciding.

No circular dependencies between layers. Higher layers may fire less often.

### 4.4 Timescale Independence

Every rule is a rate or probability per unit time. The evaluator multiplies by dt.

```
Continuous:   field.growth += fertility * 0.1 * dt
Stochastic:   p_fire = 1 - (1 - 0.02)^dt
```

Batch modes (auto-selected by evaluator):

```
Accumulate(rate * dt)                    deterministic continuous
BernoulliOnce(1 - (1-p)^dt)             did event fire at least once?
PoissonCount(p * dt)                     how many times in window?
NormalApprox(mean*dt, var*dt)            CLT for large groups
TimeToThreshold(remaining/rate)          skip ticks entirely
```

Selection:

```
single entity + small dt   → exact roll or accumulate
single entity + large dt   → BernoulliOnce or GeometricTime
group + small dt            → PoissonCount
group + large dt            → NormalApprox
goal has threshold          → TimeToThreshold
```

### 4.5 Adaptive Timestep

```
Combat / player-observed:    dt = minutes
Local settlement:            dt = 1 day
Off-screen peacetime:        dt = 30 days
World gen / history:         dt = 1 year
```

Same rules. Same evaluator. Different dt.

### 4.6 Rules as Switches

```
rule.prob = 0 → rule never fires
            → every plan with `wait` on dependent condition: step.prob = 0
            → plan.confidence = 0
            → planner never selects it
            → cascades to compounds, counters, roles
```

### 4.7 Core Rules (L0 — Physics)

```acf
rule temperature [physics, L0] {
    solar:    when region.exposed_sky > 0,
              rate = region.latitude_heat * world.season_modifier,
              effect: region.temperature += rate * dt

    conduct:  when edge(region, adj, adjacent),
              rate = (adj.temperature - region.temperature) * edge(region, adj, adjacent).conductivity,
              effect: region.temperature += rate * dt

    altitude: rate = region.altitude * 0.006,
              effect: region.temperature -= rate
}

rule water [physics, L0] {
    evaporate: when region.water > 0,
               rate = region.temperature * 0.05,
               effect: region.water -= rate * dt

    rain:      when region.humidity > 70,
               prob = region.humidity * 0.01,
               effect: region.water += 30

    flow:      when region.water > region.capacity AND edge(region, adj, adjacent),
               rate = (region.water - region.capacity) * edge(region, adj, adjacent).flow_rate,
               effect: region.water -= rate * dt,
               effect: adj.water += rate * dt

    freeze:    when region.temperature < 0 AND region.water > 0,
               rate = region.water * 0.1,
               effect: region.ice += rate * dt,
               effect: region.water -= rate * dt

    thaw:      when region.temperature > 0 AND region.ice > 0,
               rate = region.ice * 0.1,
               effect: region.water += rate * dt,
               effect: region.ice -= rate * dt
}

rule fire [physics, L0] {
    spread:  when region.fire > 0 AND adjacent.has(Flammable),
             prob = region.fire * adjacent.flammability * 0.01,
             effect: adjacent.fire += 20

    consume: when region.fire > 0,
             rate = region.fire * 0.1,
             effect: region.fuel -= rate * dt

    quench:  when region.fire > 0 AND region.water > 0,
             rate = region.water * 0.5,
             effect: region.fire -= rate * dt

    starve:  when region.fire > 0 AND region.fuel <= 0,
             rate = 20,
             effect: region.fire -= rate * dt
}

rule light [physics, L0] {
    surface: effect: region.light = sun_curve(world.time, region.latitude)
    underground: when region.depth > 0,
                 effect: region.light = 0
}
```

### 4.8 Core Rules (L1 — Biology)

```acf
rule crop_growth [biology, L1] {
    grow:    when field.planted AND region.temperature > 5 AND region.water > 20 AND region.light > 0,
             rate = field.fertility * 0.1,
             effect: field.growth += rate * dt

    wilt:    when field.planted AND region.water < 10,
             rate = 0.5,
             effect: field.health -= rate * dt

    die:     when field.health <= 0,
             effect: field.planted = false

    ready:   when field.growth >= field.crop.maturity,
             effect: field.crop.ready = true
}

rule metabolism [biology, L1] {
    hunger:  rate = entity.weight * 0.01,
             effect: entity.hunger += rate * dt

    thirst:  rate = entity.weight * 0.02 * (1 + region.temperature * 0.01),
             effect: entity.thirst += rate * dt

    fatigue: rate = entity.activity_level * 0.05,
             effect: entity.fatigue += rate * dt

    starve:  when entity.hunger > 90,
             rate = 0.5,
             effect: entity.health -= rate * dt

    dehydrate: when entity.thirst > 90,
               rate = 1.0,
               effect: entity.health -= rate * dt

    death:   when entity.health <= 0,
             effect: entity => destroy,
             effect: entity.location => create(corpse, { source = entity })
}

rule healing [biology, L1] {
    natural: when entity.health < entity.health_max AND entity.hunger < 50 AND entity.fatigue < 50,
             rate = entity.attributes.bod * 0.01,
             effect: entity.health += rate * dt
}

rule disease [biology, L1] {
    spread:  when entity.infected AND co_located(entity, target) AND NOT target.immune,
             prob = entity.contagion * region.population / region.capacity * 0.01,
             effect: target.infected = true

    progress: when entity.infected,
              rate = entity.disease.virulence * (1 - entity.attributes.bod * 0.005),
              effect: entity.health -= rate * dt

    recover: when entity.infected AND entity.health > 50,
             prob = entity.attributes.bod * 0.01,
             effect: entity.infected = false,
             effect: entity.immune = true
}

rule aging [biology, L1] {
    age:     rate = 1,
             effect: entity.age += rate * dt

    old_age: when entity.age > entity.lifespan * 0.8,
             prob = (entity.age - entity.lifespan * 0.8) / (entity.lifespan * 0.2) * 0.01,
             effect: entity.health -= 1
}
```

### 4.9 Core Rules (L2 — Items)

```acf
rule item_decay [items, L2] {
    spoil:     when item.has(Perishable) AND NOT item.location.has(cold_storage),
               rate = 0.02 * item.location.temperature / 20,
               effect: item.condition -= rate * dt

    rust:      when item.has(Material(iron)) AND item.location.humidity > 50,
               rate = item.location.humidity * 0.01,
               effect: item.condition -= rate * dt

    wear:      when item.equipped AND item.in_use,
               rate = item.use_rate * 0.01,
               effect: item.condition -= rate * dt

    break:     when item.condition <= 0,
               effect: item => destroy
}

rule structure_decay [items, L2] {
    weather:   when structure.exposed_sky > 0,
               rate = 0.01 * (1 + region.water * 0.01),
               effect: structure.condition -= rate * dt

    overload:  when structure.load > structure.capacity,
               rate = (structure.load - structure.capacity) * 0.1,
               effect: structure.condition -= rate * dt

    collapse:  when structure.condition <= 0,
               effect: structure => destroy
}

rule fuel [items, L2] {
    burn:      when fuel.in_use,
               rate = region.fire * 0.1,
               effect: fuel.amount -= rate * dt

    lamp:      when light_source.lit,
               rate = 1,
               effect: light_source.fuel -= rate * dt

    extinguish: when light_source.fuel <= 0,
                effect: light_source.lit = false
}
```

### 4.10 Core Rules (L3 — Social)

```acf
rule social_judgment [social, L3] {
    disapprove: when observer.knowledge.contains($expectation)
                AND observer.witnessed($actor, $action)
                AND $action != $expectation.expected_behavior,
                effect: edge(observer, $actor, social).reputation -= $expectation.weight

    approve:    when observer.knowledge.contains($expectation)
                AND observer.witnessed($actor, $action)
                AND $action == $expectation.expected_behavior,
                effect: edge(observer, $actor, social).reputation += $expectation.weight * 0.3
}

rule familiarity [social, L3] {
    grow:      when a.location == b.location,
               rate = 1,
               effect: edge(a, b, social).familiarity += rate * dt

    fade:      when a.location != b.location,
               rate = 1,
               effect: edge(a, b, social).familiarity -= rate * dt

    affection_fade: when edge(a, b, social).familiarity < 30,
                    rate = 0.01,
                    effect: edge(a, b, social).affection *= (1 - rate * dt)

    debt_resentment: when edge(a, b, social).debt > 50,
                     rate = 1,
                     effect: edge(a, b, social).affection -= rate * dt
}

rule knowledge_propagation [social, L3] {
    spread:    when vitem.obscurity < 0.3 AND co_located(vitem.holder, target),
               prob = (1 - vitem.obscurity) * edge(vitem.holder, target, social).familiarity * 0.01,
               effect: target => copy_vitem(vitem, confidence * 0.8)

    decay:     rate = 0.05,
               effect: vitem.freshness -= rate * dt

    normalize: when vitem.copy_count > 0,
               rate = vitem.copy_count * 0.02,
               effect: vitem.obscurity -= rate * dt
}

rule mood [social, L3] {
    hunger:    when entity.hunger > 50,
               effect: entity.mood -= 3 * dt

    comfort:   when entity.housing_quality > 50,
               effect: entity.mood += 1 * dt

    crowding:  when region.population > region.capacity,
               effect: entity.mood -= 2 * dt

    threat:    when region.threat_level > 50,
               effect: entity.mood -= region.threat_level * 0.05 * dt

    unfulfilled: when entity.drives[$drive] > 70 AND entity.fulfillment[$drive] < 30,
                 effect: entity.mood -= 5 * dt

    recovery:  when entity.mood < 50 AND entity.hunger < 30 AND entity.health > 70,
               effect: entity.mood += 2 * dt
}

rule unrest [social, L3] {
    build:     when region.avg_mood < 25 AND region.authority_strength < 40,
               rate = 5,
               effect: region.unrest += rate * dt

    revolt:    when region.unrest > 90,
               effect: region => create(rebel_faction)
}
```

### 4.11 Core Rules (L4 — Economic)

```acf
rule supply_demand [economic, L4] {
    price_up:   when region.demand[$good] > region.supply[$good],
                rate = (region.demand[$good] - region.supply[$good]) * 0.01,
                effect: region.price[$good] += rate * dt

    price_down: when region.supply[$good] > region.demand[$good],
                rate = (region.supply[$good] - region.demand[$good]) * 0.01,
                effect: region.price[$good] -= rate * dt

    floor:      when region.price[$good] < 1,
                effect: region.price[$good] = 1
}

rule supply_depletion [economic, L4] {
    consume:   when entity.weight > 0 AND entity.supplies > 0,
               rate = entity.weight * entity.consumption_rate,
               effect: entity.supplies -= rate * dt
}
```

---

## 5. Roles

### 5.1 Structure

A role is a set of prioritized condition→action rules. Evaluated every tick. Never completes. An entity holds multiple roles simultaneously. Priority sorts globally across all active roles.

```acf
role <id> [tags] {
    <name>: when <Expr>, do <ActionRef> <ActionArgs>, priority = <Expr>
    ...
}
```

### 5.2 Inheritance

```acf
role master_smith : smith [economic, craft] {
    # inherits all smith rules, can override by name, add new ones
    teach: when any(edge(self, *, apprentice_of)), do Influence.Careful { target = $apprentice, skill = crafting }, priority = 8
}
```

### 5.3 Role Acquisition / Loss

Roles are conditions that happen to be true. Not assigned.

```
gain parent   { when edge(self, *, parent_of) exists }
gain farmer   { when edge(self, *, employed_by WHERE type == farm) }
gain militia  { when edge(self, $faction, member_of) AND $faction.has_militia_duty }
lose farmer   { when NOT edge(self, *, employed_by WHERE type == farm) }
```

### 5.4 Stacking and Priority

```
entity.roles = [farmer, parent, militia, community_member]

All rules from all roles → flat list → sort by priority → first matching fires.

child.hunger > 50 (parent, priority=30) beats
field.crop.ready (farmer, priority=15) beats
weekday == sunday drill (militia, priority=3)
```

Max concurrent roles per entity: 5 (performance).

### 5.5 Shift-Based Activation

```acf
role farmer {
    active_when { daylight AND NOT holiday }
}

role militia {
    active_when { region.threat_level > 30 OR weekday == sunday }
}

role parent {
    active_when { true }  # always, but low priority rules
}
```

### 5.6 Universal Role Categories

```
Survival:     forager, hunter, herder, fisher
Economic:     farmer, miner, logger, merchant, porter, shopkeeper
Craft:        smith, carpenter, weaver, potter, tanner, brewer, cook
Military:     guard, soldier, scout, officer, siege_engineer
Governance:   judge, tax_collector, administrator, herald, diplomat
Knowledge:    scholar, teacher, scribe, healer, alchemist
Religious:    priest, acolyte, pilgrim, monk
Social:       entertainer, innkeeper, matchmaker, midwife
Domestic:     parent, caretaker, housekeeper
Criminal:     thief, smuggler, spy, assassin, fence
```

### 5.7 Example Roles

```acf
role farmer : laborer [economic, rural] {
    active_when { daylight AND NOT holiday }

    plow:      when season == spring AND field.state == fallow,
               do Modify.Direct { target = $field, objects = [plow] },
               priority = 10

    water:     when field.water < 20 AND nearby.water_source,
               do Transfer.Direct { source = $water_source, target = $field },
               priority = 11

    harvest:   when field.crop.ready,
               do Transfer.Direct { source = $field },
               priority = 15

    pest:      when field.pests > 0,
               do Modify.Direct { target = $field.pests },
               priority = 12

    store:     when self.inventory.food > self.needs.food * 2,
               do Transfer.Direct { item = food, to = $storehouse },
               priority = 5
}

role guard [military] {
    active_when { assigned_shift }

    patrol:    when NOT region.threat_detected,
               do Move.Direct { target = $patrol_route },
               priority = 5

    alert:     when region.threat_level > 50,
               do Influence.Direct { target = $community, info = threat },
               priority = 45

    defend:    when region.threat_level > 70,
               do Defense.Direct { target = $region },
               priority = 50

    arrest:    when witnessed(crime) AND self.skills.attack > perpetrator.skills.defense,
               do Attack.Careful { target = $perpetrator, intensity = 0.4 },
               priority = 40

    report:    when witnessed(crime),
               do Influence.Direct { target = $authority, info = $crime },
               priority = 35
}

role healer [knowledge] {
    triage:    when any(nearby WHERE health < 30),
               do Sense.Careful { target = $patient },
               priority = 30

    treat:     when patient.diagnosed AND self.skills.crafting > patient.wound.severity,
               do Modify.Careful { target = $patient, objects = [medical_supplies] },
               priority = 28

    research:  when NOT any(nearby WHERE health < 50),
               do Sense.Indirect { target = medicine },
               priority = 5
}

role parent [domestic] {
    active_when { true }

    feed:      when child.hunger > 50,
               do Transfer.Direct { give = food, to = $child },
               priority = 30

    heal:      when child.health < 50,
               do find_healer { target = $child },
               priority = 35

    watch:     when child.age < 6,
               do Sense.Careful { target = $child },
               priority = 8

    teach:     when child.age >= 6 AND child.age < 14,
               do Influence.Careful { target = $child, skill = $self.best_skill },
               priority = 5
}
```

---

## 6. Plans

### 6.1 Structure

A plan is a sequence of named steps that completes or fails. Two step types: `do` (act) and `wait` (predict world state change).

```acf
plan <id> [tags] {
    params { ... }
    require { ... }
    method <name> {
        when { ... }
        priority = <Expr>
        <name>: do <ActionRef> <Args>
        <name>: wait <Expr>
        ...
    }
    done { <Expr> }
    fail { <Expr> }
    counter <threat_id> { ... }
}
```

### 6.2 Step Types

```
do Action.Approach { params }     actor executes an action
do plan_or_compound_id { params } actor executes a sub-plan
wait <Expr>                       actor waits for condition (rule, other actor, anything)
```

### 6.3 Probability

Every step has a computable probability. Always an Expression, never a constant.

```
step.prob:
    do action:    sigmoid(actor.skills[skill] + actor.attributes[attr] - difficulty)
    do sub-plan:  sub_plan.confidence
    wait:         prob(condition_expr) or rule.prob scaled by dt

plan.confidence = product(step.prob for critical path)
plan.utility = confidence * goal_value - total_cost
```

### 6.4 Branching

```acf
BREACH: do military.breach_walls { walls = $target.walls }
    prob = sigmoid(force.skills.attack - target.walls.condition * 0.5)
    fail = STARVE
```

`fail = LABEL` jumps to that step on failure. Without it, plan fails on step failure.

### 6.5 Method Selection

Multiple methods per plan. Planner picks by:

1. `when` preconditions met
2. Highest `priority` among valid methods
3. Priority is an Expression (can depend on actor drives, world state)

### 6.6 Plan Decomposition Depth

Plans can reference other plans as sub-steps. Max depth: 6.

```
Depth 0: faction plan (SIEGE)
Depth 1: phase (ASSEMBLE, BREACH, STORM)
Depth 2: task (recruit, march, build_siege_tower)
Depth 3: compound (gather_wood, craft_components, haul)
Depth 4: leaf (do Modify.Indirect { ... })
```

Lazy decomposition: only decompose the current step.

### 6.7 Counter-Plans

Trigger from observable world state. Never reference drives, plans, knowledge, mood.

```acf
counter threat.troops_massing {
    military.fortify      when self.walls.condition > 30
    military.sortie       when self.garrison > force.weight * 0.3
    political.call_allies when any(edge(self, *, alliance))
}
```

Observable state only: pos, weight, faction, garrison, walls, equipped, visible actions, buildings, terrain.

Counter depth max: 4. Beyond that, knowledge confidence too degraded.

### 6.8 Group Execution

Groups split effort across concurrent plans via fractional allocation.

```
group.active_plans:
  siege_phase_2:     allocation = 0.60
  maintain_supply:   allocation = 0.25
  scout_perimeter:   allocation = 0.15

sum(allocations) <= 1.0
max concurrent plans: 4
min allocation: 0.05
```

Effective weight per action = group.weight × allocation × action_fraction.

### 6.9 Example Plans

```acf
plan economic.store_for_winter [economic, survival] {
    params { storehouse = SpatialRef }

    method default {
        when { season == autumn }
        priority = self.drives.survival * 0.8

        assess:  do Sense.Indirect { target = $storehouse }
        gather:  do Transfer.Direct { source = $fields }
            prob = sigmoid(self.skills.gathering - 10)
        process: do Modify.Careful { target = $food, objects = [salt, jars] }
        store:   do Transfer.Direct { item = $food, to = $storehouse }
        done_check: wait $storehouse.food > winter_duration * self.consumption_rate
    }

    done { self.supplies > winter_duration * self.consumption_rate }
    fail { season == winter AND self.supplies < winter_duration * self.consumption_rate * 0.5 }
}

plan social.resolve_dispute [social, governance] {
    params {
        party_a = EntityRef
        party_b = EntityRef
    }

    method mediate {
        when {
            self.skills.persuasion > 30
            edge(self, $party_a, social).familiarity > 20
            edge(self, $party_b, social).familiarity > 20
        }
        priority = self.drives.belonging * 0.6

        listen_a:    do Sense.Careful { target = $party_a }
        listen_b:    do Sense.Careful { target = $party_b }
        propose:     do Influence.Careful { target = $party_a }
            prob = sigmoid(self.skills.persuasion - abs(edge($party_a, $party_b, social).affection) * 0.5)
        confirm:     do Influence.Careful { target = $party_b }
            prob = sigmoid(self.skills.persuasion - abs(edge($party_a, $party_b, social).affection) * 0.5)
    }

    method escalate_to_authority {
        when { any(nearby WHERE role == judge) }
        priority = self.drives.lawful * 0.4

        report: do Influence.Direct { target = $judge, info = $dispute }
        defer:  wait edge($judge, $party_a, social).debt != edge($judge, $party_b, social).debt
    }

    done { edge($party_a, $party_b, social).affection > -20 }
    fail { edge($party_a, $party_b, social).affection < -80 }
}

plan military.raid [military, offensive] {
    params {
        target_region = SpatialRef
        force = EntityRef
    }

    require { attack >= 30 }

    method hit_and_run {
        when {
            force.weight > 20
            force.skills.move > 30
        }
        priority = force.drives.dominance * 0.5

        scout:     do Sense.Careful { target = $target_region, secrecy = 0.8 }
            prob = sigmoid(force.skills.observation - target_region.guard_level)
        march:     do Move.Indirect { destination = $target_region, secrecy = 0.7 }
        STRIKE:    do Attack.Direct { target = $target_region, intensity = 0.9 }
            prob = sigmoid(force.skills.melee + force.weight * 0.1 - target_region.garrison)
        loot:      do Transfer.Direct { source = $target_region, secrecy = 0.3 }
        RETREAT:   do Move.Direct { destination = $home, intensity = 0.9 }
    }

    method ambush {
        when {
            force.skills.traps > 40
            target_region.trade_route
        }
        priority = force.drives.dominance * 0.3 + (1 - force.drives.moral) * 0.3

        scout:     do Sense.Indirect { target = $target_region.trade_route }
        hide:      do Defense.Indirect { target = $ambush_point, secrecy = 0.9 }
        spring:    wait any(entity WHERE faction != self.faction AND AT(entity, $ambush_point))
        STRIKE:    do Attack.Indirect { target = $victim, intensity = 0.8 }
            prob = sigmoid(force.skills.traps + 20 - $victim.skills.observation)
        loot:      do Transfer.Direct { source = $victim }
        RETREAT:   do Move.Indirect { destination = $home, secrecy = 0.8 }
    }

    done { self.inventory.value > pre_raid_value * 1.5 }
    fail { force.weight < force.initial_weight * 0.5 }

    counter threat.raiders_spotted {
        military.fortify        when self.garrison > 30
        military.ambush_raider  when self.skills.traps > 40
        military.call_allies    when any(edge(self, *, alliance))
        economic.hide_valuables when self.garrison < 20
    }
}
```

---

## 7. Composable Compounds

Compounds are small reusable plans. Same structure, tagged [reusable].

### 7.1 Information

```acf
plan investigate [information, reusable] {
    params { target = EntityRef }
    survey:  do Sense.Careful { target = $target }
    dig:     do Sense.Indirect { target = $target.secrets }
    verify:  do Sense.Direct { target = $evidence }
}

plan eavesdrop [information, reusable] {
    params { target = EntityRef }
    position: do Move.Careful { target = $target.location, secrecy = 0.9 }
    listen:   do Sense.Careful { target = $target, secrecy = 0.9 }
}

plan surveillance [information, reusable] {
    params { target = EntityRef, duration = Number }
    position: do Move.Careful { target = $target.location, secrecy = 0.8 }
    watch:    do Sense.Careful { target = $target, secrecy = 0.8 }
    record:   wait world.time > start_time + $duration
}
```

### 7.2 Deception

```acf
plan false_identity [deception, reusable] {
    params { audience = EntityRef }
    craft:    do Modify.Indirect { target = $disguise }
    plant:    do Influence.Indirect { target = $audience, false = true }
    maintain: do Influence.Careful { target = $audience, secrecy = 0.8 }
}

plan plant_false_evidence [deception, reusable] {
    params { target_location = SpatialRef, discoverer = EntityRef }
    forge:  do Modify.Indirect { target = $fake_evidence }
    place:  do Move.Careful { target = $target_location, secrecy = 0.9 }
    leak:   do Influence.Indirect { target = $discoverer }
}

plan frame_target [deception, reusable] {
    params { patsy = EntityRef, authority = EntityRef }
    forge:   do plant_false_evidence { target_location = $patsy.location }
    coerce:  do Influence.Indirect { target = $witness, false = true }
    accuse:  do Influence.Direct { target = $authority, info = $accusation }
        prob = sigmoid(self.skills.intrigue - $authority.skills.observation)
    done { edge($authority, $patsy, social).reputation < -30 }
}

plan cover_tracks [deception, reusable] {
    destroy: do Modify.Direct { target = $evidence, destroy = true }
    alibi:   do Influence.Indirect { target = $witness, false = true }
    divert:  do plant_false_evidence { target_location = $elsewhere }
}
```

### 7.3 Social Manipulation

```acf
plan seduce [social, reusable] {
    params { target = EntityRef }
    assess:   do Sense.Careful { target = $target }
    approach: do Influence.Direct { target = $target, intensity = 0.5 }
    bond:     do Influence.Careful { target = $target, intensity = 0.7 }
    done { edge(self, $target, social).affection > 60 }
}

plan blackmail [social, criminal, reusable] {
    params { target = EntityRef }
    dirt:     do Sense.Indirect { target = $target.secrets }
    confront: do Influence.Direct { target = $target, intensity = 0.8 }
    demand:   do Transfer.Careful { from = $target }
}

plan bribe [social, economic, reusable] {
    params { target = EntityRef, payment = ObjectRef }
    assess: do Sense.Careful { target = $target.drives }
    offer:  do Transfer.Careful { give = $payment, to = $target }
    bind:   do Influence.Indirect { target = $target }
}

plan turn_agent [social, espionage, reusable] {
    params { target = EntityRef }
    assess:     do Sense.Careful { target = $target.drives }
    compromise: do blackmail OR seduce OR bribe { target = $target }
    task:       do Influence.Indirect { target = $target, info = $orders, secrecy = 0.9 }
}

plan gossip_campaign [social, reusable] {
    params { target = EntityRef, audience = EntityRef }
    gather: do Sense.Indirect { target = $target }
    spin:   do Influence.Indirect { target = $audience, info = $negative_info }
    repeat: do Influence.Indirect { target = $audience_2, info = $negative_info }
    done { edge($audience, $target, social).reputation < -30 }
}
```

### 7.4 Economic

```acf
plan smuggle [economic, criminal, reusable] {
    params { goods = ObjectRef, buyer = EntityRef }
    hide:     do Modify.Indirect { target = $goods, secrecy = 0.9 }
    transport: do Move.Indirect { cargo = $goods, secrecy = 0.9 }
    deliver:  do Transfer.Direct { give = $goods, to = $buyer, secrecy = 0.8 }
}

plan embargo [economic, political, reusable] {
    params { target_faction = EntityRef, trade_route = SpatialRef }
    blockade: do Defense.Indirect { target = $trade_route }
    enforce:  do Attack.Careful { target = $violators }
    pressure: do Influence.Direct { target = $target_faction }
}

plan price_manipulation [economic, reusable] {
    params { commodity = ObjectRef }
    corner:   do Transfer.Indirect { buy_all = $commodity }
    restrict: do Defense.Indirect { target = $supply_chain }
    profit:   do Transfer.Careful { sell = $commodity }
}
```

### 7.5 Political

```acf
plan coup [political, reusable] {
    params { target_leader = EntityRef }
    recruit:  do turn_agent { targets = $key_subordinates }
    position: do Move.Careful { forces = $loyalists, target = $power_centers, secrecy = 0.8 }
    strike:   do Attack.Direct { target = $target_leader, intensity = 0.9 }
    declare:  do Influence.Direct { target = $population, info = $new_order }
}

plan undermine_authority [political, reusable] {
    params { target_leader = EntityRef }
    dissent:  do gossip_campaign { target = $target_leader, audience = $population }
    weaken:   do Influence.Indirect { target = $target_leader.allies }
    provoke:  do Influence.Indirect { target = $target_leader }
    exploit:  do Influence.Direct { target = $population }
}

plan forge_alliance [political, reusable] {
    params { candidate = EntityRef }
    assess:    do Sense.Indirect { target = $candidate }
    approach:  do Influence.Careful { target = $candidate }
    negotiate: do Influence.Careful { target = $candidate, terms = $treaty }
    done { edge(self, $candidate, allied_with) }
}
```

### 7.6 Protection

```acf
plan safehouse [criminal, survival, reusable] {
    params { location = SpatialRef }
    find:    do Sense.Indirect { target = $safe_location }
    prepare: do Modify.Indirect { target = $location, secrecy = 0.9 }
    stock:   do Transfer.Direct { items = $supplies, to = $location }
}

plan escape_route [criminal, survival, reusable] {
    params { destination = SpatialRef }
    scout:   do Sense.Indirect { target = $routes }
    prepare: do Modify.Careful { target = $route, secrecy = 0.9 }
    stash:   do Transfer.Direct { items = $emergency_supplies, to = $waypoint }
}
```

### 7.7 Violence

```acf
plan ambush [military, reusable] {
    params { location = SpatialRef, target = EntityRef }
    position: do Move.Careful { target = $location, secrecy = 0.9 }
    hide:     do Defense.Indirect { target = $location, secrecy = 0.9 }
    spring:   wait any(entity WHERE entity == $target AND AT(entity, $location))
    attack:   do Attack.Indirect { target = $target, intensity = 0.9 }
        prob = sigmoid(self.skills.traps + 20 - $target.skills.observation)
}

plan assassination [criminal, political, reusable] {
    params { target = EntityRef }
    study:    do Sense.Indirect { target = $target, secrecy = 0.9 }
    approach: do Move.Careful { target = $target.location, secrecy = 0.9 }
    strike:   do Attack.Direct { target = $target, intensity = 1.0, secrecy = 0.8 }
        prob = sigmoid(self.skills.melee + self.modifier.stealth * 50 - $target.modifier.awareness * 50)
    escape:   do Move.Indirect { destination = $safehouse, secrecy = 0.9 }
}

plan sabotage [military, criminal, reusable] {
    params { target_structure = SpatialRef }
    recon:   do Sense.Careful { target = $target_structure, secrecy = 0.8 }
    access:  do Move.Careful { target = $target_structure, secrecy = 0.9 }
    damage:  do Modify.Direct { target = $target_structure, destroy = true, secrecy = 0.7 }
    escape:  do Move.Indirect { destination = $safehouse, secrecy = 0.9 }
}

plan kidnap [criminal, reusable] {
    params { target = EntityRef, hideout = SpatialRef }
    stalk:   do Sense.Careful { target = $target, secrecy = 0.9 }
    isolate: wait $target.location.population < 3
    grab:    do Attack.Direct { target = $target, intensity = 0.6, secrecy = 0.8 }
    move:    do Move.Indirect { cargo = $target, destination = $hideout, secrecy = 0.9 }
    demand:  do Influence.Direct { target = $target.faction, info = $ransom }
}
```

---

## 8. Priority Resolution

```
1. Active plan step (if plan assigned and preconditions met)
2. Highest-priority rule across all active roles
3. Default idle behavior
```

---

## 9. Provenance

`_provenance { }` section. Stripped by loader: `if key.startsWith("_"): skip`.

```acf
_provenance {
    sources = [
        { type = military_doctrine, id = fm3-90_ch12, confidence = 0.95 }
        { type = tvtropes, id = trope:TheSiege, confidence = 0.7 }
    ]
    model = claude-sonnet-4-20250514
    prompt_version = extract_task_v3
    verified = true
    reviewer = manu
    notes = "Adjusted force ratio from 3x to 2x"
}
```

Stats in separate `.stats.acf` sidecars. Gitignored, runtime-generated.

---

## 10. Validation Rules

```
1.  Every Expression resolves to STAT/EDGE/CONST/PARAM terminals
2.  Every do uses valid Action × Approach from 7×3 table
3.  Every plan decomposes to leaf actions within depth 6
4.  Every step has a name (bare `do` without name: is a parse error)
5.  Every prob Expression is bounded 0..1 (sigmoid/prob/min/max)
6.  No references to authority or reputation as stored stats
7.  Counter observables reference only externally visible state
    (NOT: drives, plans, knowledge, mood, skills, contracts)
8.  Counter chains terminate within depth 4
9.  No circular references in plan decomposition
10. All $param references have matching param definitions
11. sum(group allocations) <= 1.0, max 4 concurrent, min 0.05
12. Rule layers respect dependency order (L0→L1→L2→L3→L4)
13. Every wait in a plan implies a rule or condition that can produce the awaited state
```

Enforced at: LLM self-check → post-generate script → git pre-commit → CI.

---

## 11. Bundles

Compatible sets of rules + roles + plans + v-items + rule values. Local to spatial nodes. Discovered by sim, not authored.

```acf
bundle governance.feudal [governance] {
    expectations {
        obey_lord        { weight = 0.8, context = same_region }
        pay_taxes        { weight = 0.7, context = same_faction }
        military_service { weight = 0.6, context = when_called }
    }
    roles  { lord, vassal, serf, knight, bailiff }
    plans  { political.swear_fealty, political.grant_fief, military.levy_troops }
    rules  { loyalty_decay = 0.05, social_mobility = 0.01 }
    compatible   { economy.agrarian, economy.manor }
    incompatible { governance.democracy }
}
```

---

## 12. Profiles

Rule value tables. Same plans and roles, different game.

```acf
profile realistic {
    fire_spread.prob = 0.1
    disease_spread.prob = 0.05
    crop_growth.rate = 0.1
    food_spoilage.rate = 0.02
    rumor_spread.rate = 0.3
}

profile harsh {
    fire_spread.prob = 0.3
    disease_spread.prob = 0.15
    crop_growth.rate = 0.05
    food_spoilage.rate = 0.08
    rumor_spread.rate = 0.5
}
```
