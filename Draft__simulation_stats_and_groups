# Group-Level Pathfinding: Flow, Capacity, and Throughput

## The Problem

Individual A* pathfinding costs O(N Ã— map_size) per tick for N entities. With 10,000 entities that's catastrophic. But group movement isn't just "run A* once for the group" â€” groups have width, they saturate corridors, they split around obstacles, and their movement takes time proportional to group size.

The solution mirrors the rest of the system: pathfinding operates at whatever granularity the tree node exists at. Leaf nodes get tile-level paths. Compound nodes get region-level flow.

---

## The Region Graph

The spatial hierarchy already defines a graph at every level:

```
Tile graph:        100,000 nodes, 4-8 edges each     â† individual pathfinding
Region graph:      ~200 nodes, 3-6 edges each         â† group pathfinding  
Zone graph:        ~15 nodes, 2-4 edges each           â† strategic movement
Province graph:    ~5 nodes                            â† world map
```

Each edge in the region graph represents a **connection** between adjacent regions: a doorway, a road segment, a corridor, an open border. Each connection has properties:

```
Connection {
    regions: (RegionId, RegionId)
    width: u16              // how many tiles wide the passage is
    throughput: f32          // entities per game-second that can pass
    terrain_cost: f32        // movement speed modifier (road=0.5, swamp=3.0)
    current_flow: f32        // how much traffic is using this right now
    capacity_remaining: f32  // throughput - current_flow
}
```

Throughput is the key concept. A 2-tile-wide doorway has much lower throughput than a 10-tile-wide road. A group of 200 moving through a doorway doesn't teleport through â€” it queues.

---

## Movement by Tree Depth

### Leaf Nodes (weight=1): Tile-Level Pathfinding

Standard A* on the tile graph. Only used for:
- Player-directed individual movement
- Solo entities in active pursuit/flee
- Entities navigating within a single region (short range, small search space)

Even here, the region graph helps: hierarchical A* finds the region-level path first, then tile-level A* only runs within each region along the route. Search space drops from 100,000 to maybe 500 tiles.

### Compound Nodes (weight=5â€“200): Region-Level Flow

The group doesn't pathfind. It **flows**. The system computes a flow field from the group's current region to its destination region, and the group moves along it subject to throughput constraints.

A group at Region(MINE_3) wants to reach Region(BARRACKS_1):

1. **Route**: A* on the region graph. Returns a sequence of regions: MINE_3 â†’ CORRIDOR_7 â†’ HALL_2 â†’ BARRACKS_1. Cost: trivial (200 nodes).

2. **Flow rate**: The bottleneck connection along the route determines maximum flow. If CORRIDOR_7 has a 2-tile doorway with throughput=4/sec and the group is 200, it takes 50 game-seconds for the full group to pass.

3. **Movement state**: The group's location stat transitions through intermediate states:

```
t=0:    location = Region(MINE_3),      weight=200
t=10:   location = Transitioning,       40 in CORRIDOR_7, 160 still in MINE_3
t=30:   location = Transitioning,       120 in HALL_2, 60 in CORRIDOR_7, 20 in MINE_3
t=55:   location = Region(BARRACKS_1),  weight=200
```

During transition, the node temporarily refines along the spatial axis â€” not to individual level, but into sub-groups per region along the route. These sub-groups coarsen back once the full group arrives.

4. **Contention**: If another group is also using CORRIDOR_7, their flows compete for the throughput. The system allocates capacity proportionally or by priority. This naturally creates traffic jams at bottlenecks without simulating individual collision.

### High-Level Nodes (weight=1000+): Zone-Level Strategic Flow

Large-scale movements (army marching, mass migration, seasonal workforce redistribution) operate on the zone graph. The route is a sequence of zones. Flow rate is determined by inter-zone connection throughput (road networks, mountain passes).

At this level, movement is essentially a resource transfer: "500 soldiers flow from ZONE_MILITARY to ZONE_FRONTIER at rate 50/day, limited by road capacity."

---

## Flow Fields

For repeated or concurrent movements toward the same destination, precompute a **flow field** on the region graph: for every region, store the next-hop direction toward the destination. All groups heading to the same target share the field.

```
Flow field toward MARKET_SQUARE:

    FARM_1 â†’ ROAD_NORTH â†’ GATE_1 â†’ MARKET_SQUARE
    FARM_2 â†’ ROAD_NORTH â†’ GATE_1 â†’ MARKET_SQUARE
    MINE_3 â†’ CORRIDOR_7 â†’ HALL_2 â†’ MARKET_SQUARE
    BARRACKS_1 â†’ HALL_2 â†’ MARKET_SQUARE
```

Flow fields are cheap to compute (Dijkstra on ~200 nodes) and can be cached. Invalidate when the region graph topology changes (wall built, door locked, bridge destroyed).

Common destinations that justify persistent flow fields:
- Dining halls (daily meal flow)
- Workplaces (morning commute flow)
- Markets / warehouses (hauling flow)
- Barracks (military mustering flow)
- Temples (worship flow)

These are essentially the "desire paths" of the city. They emerge from the region graph + connection throughputs and can be visualized for the player as traffic heat maps.

---

## Throughput Simulation

Each connection in the region graph has a throughput capacity and a current utilization. Every tick:

```
for each connection:
    // Sum flow from all groups currently using this connection
    current_flow = sum(group.flow_rate for group in groups_using(connection))
    
    if current_flow > connection.throughput:
        // Congestion â€” all groups through this connection slow down proportionally
        congestion_factor = connection.throughput / current_flow   // < 1.0
        for group in groups_using(connection):
            group.effective_flow_rate = group.requested_flow_rate * congestion_factor
    else:
        // No congestion â€” groups move at full speed
        capacity_remaining = connection.throughput - current_flow
```

This handles:
- **Bottlenecks**: narrow doorways slow large groups
- **Traffic jams**: multiple groups competing for the same corridor
- **Rush hour**: morning commute to workplaces congests main roads
- **Siege chokepoints**: defenders can hold a narrow pass against a larger force because throughput limits how many attackers can engage

### Throughput Calculation

Connection throughput depends on physical properties:

```
throughput = width_in_tiles Ã— speed_modifier Ã— terrain_factor

width_in_tiles:   count of walkable tiles along the connection boundary
speed_modifier:   road=2.0, floor=1.0, rough=0.5, stairs=0.3
terrain_factor:   flat=1.0, uphill=0.6, downhill=1.2
```

This can be precomputed when regions form and cached until the spatial graph changes.

---

## Shell Movement (Rendering)

The simulation says "200 miners are transitioning from MINE_3 to BARRACKS_1 via CORRIDOR_7 at rate 4/sec." The renderer needs to show 200 individual sprites walking.

Shells derive their movement from the group's flow state:

1. **Route geometry**: The region-level route maps to a coarse path through region centroids or connection midpoints. This is the "spine" of the movement.

2. **Shell distribution along spine**: Shells spread along the spine proportional to how far through the transition the group is. Early shells are near the destination, late shells are near the origin. This looks like a stream of people walking.

3. **Lateral spread**: Shells offset perpendicular to the spine based on connection width. Narrow corridor = tight column. Wide road = spread formation. This happens automatically from the connection geometry.

4. **Per-shell noise**: Small random offsets in position and speed so they don't march in lockstep. Stagger animations. This is purely cosmetic.

5. **Bottleneck queuing**: When shells reach a narrow connection, they visually bunch up at the entrance and trickle through. This isn't simulated per-shell â€” the shell positions are derived from the group's flow rate at each connection. Slow flow rate = dense shell packing before the bottleneck.

No per-shell pathfinding. No collision detection between shells. The visual movement is entirely derived from the group's flow state through the region graph.

---

## Interaction Between Flow and Tree Refinement

Flow and grouping interact at two points:

### Groups Split During Movement

If a group encounters a fork in its route (destination reachable via two paths), it can split to use both paths and increase total throughput:

```
Cohort(200 miners) heading to DINING_HALL
    Route A: MINE â†’ CORRIDOR_NORTH â†’ DINING_HALL  (throughput 3/sec)
    Route B: MINE â†’ CORRIDOR_SOUTH â†’ DINING_HALL  (throughput 5/sec)
    
    Split proportional to throughput:
    SubGroup_A(75)  takes Route A
    SubGroup_B(125) takes Route B
    
    Both arrive, coarsen back into one group at DINING_HALL
```

This is a spatial-axis refinement triggered by pathfinding, not by simulation need. The sub-groups exist only during transit and merge at the destination.

### Flow Creates Congestion Events

When congestion exceeds a threshold, it can trigger simulation-level consequences:

- **Mood penalty**: "crowded corridor" mood modifier applied to group stats
- **Lateness**: workers arriving late to workplace reduce production for that tick
- **Stampede risk**: extremely high congestion + low morale â†’ stochastic event â†’ refine some entities to solo for stampede/crush simulation
- **Player signal**: traffic heat map highlights bottlenecks, prompting the player to build wider roads or additional routes

---

## Hauling as Flow

Item transport isn't individual haulers carrying individual items. It's **flow between inventory nodes**.

```
Warehouse(MINE_3, iron_ore, weight=500)
    needs to flow to â†’
Warehouse(SMELTER_2, iron_ore, weight=0)

Flow rate = hauler_throughput(connection MINE_3 â†’ SMELTER_2) Ã— hauler_count
```

Haulers aren't individually simulated. They're a throughput multiplier on the connection between the source and destination inventory nodes. More haulers assigned to a route = higher flow rate. The "hauling cohort" is just a population node whose role is to amplify connection throughput.

Visually, shells representing haulers walk back and forth along the route carrying sprites of the resource. Their count and speed derive from the flow rate. Again, no individual pathfinding.

### Supply Chain as Flow Network

The entire production economy becomes a flow network on the region graph:

```
FARM â†’ (grain) â†’ MILL â†’ (flour) â†’ BAKERY â†’ (bread) â†’ DINING_HALL
         flow=20/day    flow=15/day     flow=12/day

Bottleneck: BAKERY output. Solution: build second bakery, or upgrade road to BAKERY.
```

Each arrow is a flow edge with throughput determined by both connection capacity and production rate. The player's job is optimizing this flow network â€” and the system can visualize it directly as flow volumes on the region graph.

---

## Pathfinding Cost Summary

| Tree depth | Path method | Graph size | Cost per group | When used |
|---|---|---|---|---|
| Leaf (weight=1) | Hierarchical A* | ~500 tiles (local) | O(500) | Player-directed, pursuit/flee |
| Compound (5â€“200) | A* on region graph + flow | ~200 regions | O(200) + flow bookkeeping | Normal group movement |
| Large compound (1000+) | A* on zone graph + flow | ~15 zones | O(15) | Army march, migration |
| Strategic | Direct edge | ~5 provinces | O(1) | World map transfer |

Total pathfinding cost per tick: O(region_graph) for flow field computation + O(active_flows) for throughput updates. Both are independent of population. 10,000 entities moving around a city costs the same as 100 â€” they just produce more congestion.

---

## Connection to the Unified Tree

Flow state is just another stat dimension on the node:

```
stats.movement: MovementStat
    // At rest:
    Stationary { region: RegionId }
    
    // In transit:
    Flowing { 
        route: RegionId[],        // planned path
        progress: f32,            // 0.0 = origin, 1.0 = destination
        flow_rate: f32,           // current effective rate (after congestion)
        bottleneck: ConnectionId  // what's limiting speed, for UI
    }
```

When a node is Stationary, its location stat is a single region. When Flowing, its location is implicitly spread along the route â€” and if the tree needs to refine during transit, it splits into sub-nodes per route segment (each Stationary in their current region). Coarsening after arrival collapses them back.

The flow field, connection throughputs, and congestion state live on the region graph â€” shared infrastructure that all nodes reference. They aren't per-node state. A node just says "I want to go from A to B" and the region graph resolves how fast that happens.
